{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"PyARV","text":"<p>Python wrapper of a C implementation of approximate random variables as detailed in:</p> <p>Michael B. Giles and Oliver Sheridan-Methven.  Approximating inverse cumulative distribution functions to produce approximate random variables.  ACM Transactions on Mathematical Software, 49(3), Article 26, September 2023, 29 pages.  https://doi.org/10.1145/3604935</p>"},{"location":"index.html#authors","title":"Authors","text":"<p>Dr Oliver Sheridan-Methven oliver.sheridan-methven@hotmail.co.uk.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The full documentation can be found here: Documentation.</p>"},{"location":"LICENSE.html","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Dr Oliver Sheridan-Methven.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"FAQs/index.html","title":"FAQs","text":"<p>Frequently asked questions. </p>"},{"location":"FAQs/why_python_and_c.html","title":"Why Python and C?","text":"<p>This project is a Python wrapper of C implementations. </p>"},{"location":"FAQs/why_python_and_c.html#python","title":"Python","text":"<p>It's the original author's favourite language, so it seemed a reasonable choice (as good as any other).</p>"},{"location":"FAQs/why_python_and_c.html#c","title":"C","text":"<p>The original ACM TOMS paper provides mathematical recipes for producing approximate random numbers, and the speed improvements derive from exploiting SIMD hardware. To go down to such a low-level brings us to the realms of the usual compiled HPC languages such as  C, C++, Fortran, Rust, etc. The original author doesn't know  Fortran or Rust very well, so that leaves us with C or C++. </p> <p>Choosing between C and C++ was a hard decision, and either  would be a good platform to implement the underlying routines.  So why C and not C++:</p> <ul> <li>The approximations use some type punning (between <code>int</code> and <code>float</code>),  and this is  easily done in C using unions (and is defined behaviour in C, including C99 onwards,  cf. https://stackoverflow.com/a/25664954/5134817 and https://stackoverflow.com/a/25672839/5134817),  whereas in C++ type punning is much trickier to do correctly  (without producing undefined behaviour). </li> <li>C has the keyword <code>restrict</code> which does not exist in C++ without  compiler extensions (which we would prefer to avoid for portability), and this is something we take advantage of for optimisation.</li> <li>C is the lingua franca for HPC and portability.</li> <li>Python and NumPy have C APIs, and these are the initial  targets for our wrappers.</li> </ul>"},{"location":"FAQs/why_python_and_c.html#why-not-c-fortran-rust-julia-matlab-javascript-etc","title":"Why not C++, Fortran, Rust, Julia, MATLAB, JavaScript, etc.","text":"<p>Creating interfaces for the various languages should be easy enough, and if the package proves popular we welcome contributions to help us widen the scope.</p> <p>For the higher level languages we hope to wrap our C code similar to how we have for Python. For the lower level languages,  either use wrappers, re-implement in the preferred language, or use  langauge features, such as e.g. C++'s <code>extern \"C\"</code>. </p>"},{"location":"User_API/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>approximations<ul> <li>polynomial approximations</li> </ul> </li> <li>gaussian<ul> <li>approximation</li> </ul> </li> <li>non central chi squared<ul> <li>approximation</li> </ul> </li> <li>type hints<ul> <li>arrays</li> </ul> </li> <li>version</li> </ul>"},{"location":"User_API/approximations/index.html","title":"approximations","text":"<p>The general framework for our approximations.</p>"},{"location":"User_API/approximations/polynomial_approximations.html","title":"polynomial approximations","text":"<p>The interface we specify for our approximations.</p>"},{"location":"User_API/approximations/polynomial_approximations.html#approximations.polynomial_approximations.PolynomialApproximationTransformer","title":"<code>PolynomialApproximationTransformer(*args, use_preallocated_output_array=False, order=1, cache_table=True, try_cached_table=True, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The general class all polynomial approximations should derive from.</p> <p>Create the transformer.</p> <p>Parameters:</p> Name Type Description Default <code>use_preallocated_output_array</code> <code>bool</code> <p>Whether to use a user provided array with preallocated memory.</p> <code>False</code> <code>order</code> <code>int</code> <p>The polynomial order.</p> <p>0 = constant. 1 = linear. 2 = quadratic. 3 = cubic. ... etc. ...</p> <code>1</code> <code>cache_table</code> <code>bool</code> <p>Should any coefficient tables be cached?</p> <code>True</code> <code>try_cached_table</code> <code>bool</code> <p>Should coefficient table caches be tried?</p> <code>True</code> Source code in <code>src/pyarv/approximations/polynomial_approximations.py</code> <pre><code>def __init__(self, \n             *args, \n             use_preallocated_output_array: bool=False,\n             order: int = 1,\n             cache_table: bool =True, \n             try_cached_table: bool =True,\n             **kwargs):\n    \"\"\"\n    Create the transformer.\n\n    Parameters\n    ----------\n    use_preallocated_output_array\n        Whether to use a user provided array with preallocated memory.\n    order\n        The polynomial order.\n\n        0 = constant.  \n        1 = linear.  \n        2 = quadratic.  \n        3 = cubic.  \n        ... etc. ...\n    cache_table\n        Should any coefficient tables be cached?\n    try_cached_table\n        Should coefficient table caches be tried? \n    \"\"\"\n    if order &lt; 0:\n        raise ValueError(f\"The polynomial order must be positive, not {order = }\")\n    if not isinstance(use_preallocated_output_array, bool):\n        raise ValueError(f\"A boolean value must be specified, not {use_preallocated_output_array = }\")\n    if not isinstance(cache_table, bool):\n        raise ValueError(f\"A boolean value must be specified, not {cache_table = }\")\n    if not isinstance(try_cached_table, bool):\n        raise ValueError(f\"A boolean value must be specified, not {try_cached_table = }\")\n    self.use_preallocated_output_array = use_preallocated_output_array\n    self.cache_table = cache_table\n    self.try_cached_table = try_cached_table\n    self.order = order\n</code></pre>"},{"location":"User_API/approximations/polynomial_approximations.html#approximations.polynomial_approximations.PolynomialApproximationTransformer.approximation","title":"<code>approximation(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>The underlying approximation and the interface between the Python and C functions. This may have additional parameters beyond those  described by <code>transform</code>. (Also responsible for generating coefficient tables and caching).</p> Source code in <code>src/pyarv/approximations/polynomial_approximations.py</code> <pre><code>@abc.abstractmethod\ndef approximation(self,\n                  *args,\n                  **kwargs) -&gt; None:\n    \"\"\"\n    The underlying approximation and the interface between the Python\n    and C functions. This may have additional parameters beyond those \n    described by `transform`. (Also responsible for generating coefficient tables\n    and caching). \n    \"\"\"\n    ...\n</code></pre>"},{"location":"User_API/approximations/polynomial_approximations.html#approximations.polynomial_approximations.PolynomialApproximationTransformer.transform","title":"<code>transform(inputs, /, *, outputs=None, **kwargs)</code>","text":"<p>Use a polynomial approximation for the inverse transform method.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Array</code> <p>Uniform random numbers in .</p> required <code>outputs</code> <code>Array | None</code> <p>A pre-allocated array containing the outputs if requested.</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments needed for any specific distribution's <code>approximation</code> implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>outputs</code> <code>Array | None</code> <p>Random variables from a desired distribution.</p> Source code in <code>src/pyarv/approximations/polynomial_approximations.py</code> <pre><code>def transform(self, \n               inputs: Array, \n               /, \n               *, \n               outputs: Array | None = None, \n               **kwargs: dict[str, Any])\\\n        -&gt; Array | None:\n    \"\"\"\n    Use a polynomial approximation for the inverse transform method.\n\n    Parameters\n    ----------\n    inputs\n        Uniform random numbers in \\( [0, 1] \\). \n    outputs\n        A pre-allocated array containing the outputs if requested. \n    kwargs\n        Keyword arguments needed for any specific distribution's `approximation` implementation. \n\n    Returns\n    -------\n    outputs:\n        Random variables from a desired distribution. \n\n    \"\"\"\n    if self.use_preallocated_output_array:\n        if len(inputs) != len(outputs):\n            raise TypeError(f\"The {outputs = } must be the same length as the {inputs = }\")\n        if outputs.shape != inputs.shape:\n            raise TypeError(f\"The {outputs.shape} must match the {inputs.shape}\")\n        if not inputs.flags['C_CONTIGUOUS']:\n            raise TypeError(f\"The {inputs = } must be C-contiguous.\")\n        if not outputs.flags['C_CONTIGUOUS']:\n            raise TypeError(f\"The {outputs = } must be C-contiguous.\")\n        if inputs.dtype != np.float32:\n            raise TypeError(f\"The {inputs.dtype = } must be {np.float32}.\")\n        if outputs.dtype != inputs.dtype:\n            raise TypeError(f\"The {outputs.dtype = } must match {inputs.dtype = }.\")\n        if outputs is inputs:\n            raise ValueError(f\"Must use different objects for output, {inputs is outputs = }\")\n        if outputs.base is inputs or inputs.base is outputs:\n            raise ValueError(f\"The inputs and output arrays must not share any memory.\")\n\n    if not self.use_preallocated_output_array:\n        if outputs is not None:\n            raise ValueError(f\"{self.use_preallocated_output_array = }, but {outputs = } has been provided.\")\n        outputs = np.empty_like(inputs)\n\n    self.approximation(inputs=inputs, outputs=outputs, order=self.order, **kwargs)\n    return outputs\n</code></pre>"},{"location":"User_API/gaussian/index.html","title":"gaussian","text":"<p>The Gaussian distribution, a.k.a. the Normal distribution.</p>"},{"location":"User_API/gaussian/approximation.html","title":"approximation","text":""},{"location":"User_API/gaussian/approximation.html#gaussian.approximation.Gaussian","title":"<code>Gaussian</code>","text":"<p>               Bases: <code>PolynomialApproximationTransformer</code></p> <p>Polynomial approximation to the inverse CDF of the Gaussian distribution,  .</p>"},{"location":"User_API/non_central_chi_squared/index.html","title":"non central chi squared","text":"<p>The non-central  distribution.</p>"},{"location":"User_API/non_central_chi_squared/approximation.html","title":"approximation","text":""},{"location":"User_API/non_central_chi_squared/approximation.html#non_central_chi_squared.approximation.NonCentralChiSquared","title":"<code>NonCentralChiSquared(*args, **kwargs)</code>","text":"<p>               Bases: <code>PolynomialApproximationTransformer</code></p> <p>Polynomial approximation to the inverse CDF of the non-central  distribution.</p> Source code in <code>src/pyarv/non_central_chi_squared/approximation.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.cached_tables = {}\n</code></pre>"},{"location":"User_API/non_central_chi_squared/approximation.html#non_central_chi_squared.approximation.NonCentralChiSquared.approximation","title":"<code>approximation(*args, order, non_centralities, degrees_of_freedom, **kwargs)</code>","text":"<p>Specialism extending <code>PolynomialApproximationTransformer.transform</code>.</p> <p>Parameters:</p> Name Type Description Default <code>non_centralities</code> <code>Array</code> <p>The non-centralities, positive (zero values correspond to the central  distribution).</p> required <code>degrees_of_freedom</code> <code>float</code> <p>The degrees of freedom, strictly positive, assumed to be fixed for all values.</p> required Source code in <code>src/pyarv/non_central_chi_squared/approximation.py</code> <pre><code>def approximation(self, \n               *args,\n               order,\n               non_centralities: Array,\n               degrees_of_freedom: float,\n               **kwargs\n               ):\n    r\"\"\"\n    Specialism extending `PolynomialApproximationTransformer.transform`.\n\n    Parameters\n    ----------\n    non_centralities:\n        The non-centralities, positive (zero values correspond to the central \\( \\chi^2 \\) distribution).\n    degrees_of_freedom:\n        The degrees of freedom, strictly positive, assumed to be fixed for all values.    \n    \"\"\"\n    approximations = {1: linear}\n    if self.order not in approximations.keys():\n        raise NotImplementedError(f\"We have not yet implemented interfaced for higher order approximations. Currently we only support orders: {approximations.keys()}\")\n    polynomial_coefficients = None\n    if self.try_cached_table:\n        try:\n            polynomial_coefficients = self.cached_tables[degrees_of_freedom]\n        except KeyError:\n            logging.info(f\"There were no cached coefficients for {degrees_of_freedom = }\")\n    if polynomial_coefficients is None:\n        logging.info(f\"Generating coefficients for {degrees_of_freedom = }\")\n        polynomial_coefficients = generate_non_central_chi_squared_coefficients(n_intervals=16,\n                                                                                n_interpolation_functions=16,\n                                                                                n_polynomial_orders=self.order+1,\n                                                                                dof=degrees_of_freedom,\n                                                                                dtype=np.float32\n                                                                                )\n    assert polynomial_coefficients is not None\n    if self.cache_table:\n        logging.info(f\"Caching the coefficients for {degrees_of_freedom = }\")\n        self.cached_tables[degrees_of_freedom] = polynomial_coefficients\n    approximations[self.order](*args,\n                           non_centralities=non_centralities,\n                           degrees_of_freedom=degrees_of_freedom,\n                           polynomial_coefficients=polynomial_coefficients,\n                           **kwargs)\n</code></pre>"},{"location":"User_API/type_hints/index.html","title":"type hints","text":""},{"location":"User_API/type_hints/arrays.html","title":"arrays","text":""},{"location":"User_API/type_hints/arrays.html#type_hints.arrays.Array","title":"<code>Array = Annotated[npt.NDArray[np.float32], Literal['N']]</code>  <code>module-attribute</code>","text":"<p>The array type.</p>"},{"location":"User_API/version/index.html","title":"version","text":"<p>Version information.</p>"},{"location":"User_API/version/index.html#version.__version__","title":"<code>__version__: str</code>  <code>module-attribute</code>","text":"<p>The repo's version</p>"},{"location":"about/index.html","title":"About","text":"<p>Information about the PyARV project. </p>"},{"location":"developer_notes/index.html","title":"Developer notes","text":"<p>This section is intended only for developers. </p>"},{"location":"developer_notes/deployment.html","title":"Deployment","text":"<p>To upload this package to PyPI, we use <code>twine</code> and follow the instructions detailed in online tutorials such as e.g.:  </p> <ul> <li>https://www.freecodecamp.org/news/how-to-create-and-upload-your-first-python-package-to-pypi/ </li> <li>https://packaging.python.org/en/latest/tutorials/packaging-projects/#creating-readme-md </li> </ul> <p>Mostly it is a combination of </p> <pre><code>python3 -m build \n</code></pre> <p>and then</p> <pre><code>python3 -m twine upload --repository testpypi dist/*\n</code></pre> <p>and</p> <pre><code>python3 -m twine upload dist/*\n</code></pre>"},{"location":"developer_notes/documentation_conventions.html","title":"Documentation conventions","text":"<p>The documentation is split into two halves, aimed at users and developers separately. We currently only document the  Python interface, and the underlying C interface is not  documented (we hope to change this should the mkdocstring C handler be open sourced). </p> <p>Following the defaults used by mkdocstring-Python,  the additional convention we follow is that everything is assumed  to be user facing unless it matches any of the following  conditions:</p> <ul> <li>A parent directory contains a leading or training underscore, e.g.  <code>_foo/</code>, <code>foo_/</code>, or <code>_foo_/</code>.</li> <li>A parent directory is called <code>tests</code> or <code>demos</code>. </li> <li>A file contains a leading or trailing undercore (except <code>__init__.py</code>). </li> </ul>"},{"location":"developer_notes/updating_versions_and_releases_and_documentation.html","title":"Updating the git versions and releases","text":"<p>To list the git version tags: </p> <pre><code>git tag -l\n</code></pre> <p>To list the git version tags along with a brief 1-line description (<code>-n&lt;K&gt;</code> for <code>K</code> lines):</p> <pre><code>git tag -l -n1\n</code></pre> <p>To add a tag use:</p> <pre><code>git tag -a &lt;vX.Y.Z&gt; -m \"&lt;SOME BRIEF MESSAGE&gt;\"\n</code></pre> <p>The tag then needs to be pushed:</p> <pre><code>git push --tags\n</code></pre> <p>To set a release with a tag:</p> <pre><code>gh release create $(git describe --tags --abbrev=0)\n</code></pre>"},{"location":"developer_notes/updating_versions_and_releases_and_documentation.html#updating-the-remote-documentation","title":"Updating the remote documentation.","text":"<p>To update the documentation hosted remotely (e.g. on GitHub Pages),  then on <code>master</code> we need to redeploy the documents after  the most relevant commit by calling:</p> <pre><code>mkdocs gh-deploy --clean\n</code></pre>"},{"location":"developer_notes/build_instructions/from_source.html","title":"Building from source","text":""},{"location":"developer_notes/build_instructions/from_source.html#out-of-source-builds","title":"Out-of-source builds","text":"<p>We follow the CMake convention by only encouraging \"out-of-source\" builds, hence the reason for this build directory existing. This directory exists only for manual building and testing with <code>cmake</code> et al.</p> <p>To build the project:</p> <pre><code>cd build\ncmake .. \nmake \npip3 install .. \nctest \n</code></pre> <p>Note</p> <p><code>make test</code> and <code>ctest</code> are synonymous.</p> <p>Running things in parallel</p> <p><code>cmake</code>, <code>ctest</code>, and <code>make</code> can all use multiple cores,  to speed things up, typically by adding a <code>-j &lt;N&gt;</code> or  <code>--parallel &lt;N&gt;</code> flag. </p> <p>The reason we install the Python package is because many of our tests are Python based as well, including several  C extensions and various Python modules we have created.  Hence, without this step, the various Python imports won't work correctly and many of the tests can be expected to fail. </p>"},{"location":"developer_notes/build_instructions/from_source.html#modern-c23-compilers","title":"Modern C23 compilers","text":"<p>We are trying to use a very modern C standard (C23 is quite new at the time of writing), and compiler support for this is limited. To ensure <code>cmake</code> can find a sufficiently new compiler version, it may be necessary to hardwire paths to these in your invocation of <code>cmake</code>, e.g.:</p> <pre><code>cmake -D CMAKE_C_COMPILER=/usr/local/Cellar/gcc/13.1.0/bin/gcc-13 -D CMAKE_CXX_COMPILER=/usr/local/Cellar/gcc/13.1.0/bin/g++-13 ..\n</code></pre>"},{"location":"developer_notes/build_instructions/from_source.html#debugging","title":"Debugging","text":"<p>If any tests are failing, then these can be debugged further by running</p> <pre><code>ctest --rerun-failed --output-on-failure\n</code></pre>"},{"location":"developer_notes/build_instructions/in_source.html","title":"In source builds","text":""},{"location":"developer_notes/build_instructions/in_source.html#why-allow-in-source-builds","title":"Why allow in source builds?","text":"<p>In source builds are largely discouraged, and are only  recommended for use by developers. The reason we support this  for developers is to populate the source directory with various  generated files, libraries, etc. The use of this is for example: placing python extension libraries in the source directory.  This allowes for them to be picked up by an interpreter which can point to the in source code, rather than what is  produced by the scikit build procedure. This means code which is under development can be more easily accessed by an IDE or interpreter. </p>"},{"location":"developer_notes/build_instructions/in_source.html#making-in-source-builds","title":"Making in source builds","text":"<p>From the projects root directory run </p> <pre><code>cmake .\nmake \nmake install\nmake test \n</code></pre> <p>Note</p> <p>This is run from the project's root directory, not from a  separate dedicated build directory.</p> <p>IDES</p> <p>Adding <code>-DINSOURCE_BUILD=True</code> to the <code>cmake .</code> can allow the  IDE to propagate the appropriate source path, which is useful for  e.g. running the tests. </p>"},{"location":"developer_notes/build_instructions/in_source.html#cleaning-everything-up","title":"Cleaning everything up","text":"<p>To clean everything up, run </p> <pre><code>make clean\n./cmake_uninstall.sh\n</code></pre>"},{"location":"developer_notes/build_instructions/in_source.html#adjusting-your-pythonpath","title":"Adjusting your <code>PYTHONPATH</code>","text":"<p>If you plan on testing out the code using the source code in  the repository, such as for use in a terminal setting or an  IDE, then it might be useful to add the contents of <code>src/</code> to your <code>PYTHONPATH</code> environment variable. To do just this we have the script <code>add_src_to_python_path.sh</code> which can be run  from the project's root directory by calling:</p> <pre><code>source add_src_to_python_path.sh\n</code></pre>"},{"location":"developer_notes/build_instructions/python_bindings.html","title":"Python bindings","text":"<p>We have setup this project to wrap some of the various C libraries with Python bindings. To install these, run</p> <pre><code>cd build\npip3 install ..\n</code></pre> <p>This will call <code>scikit-build</code>, which in turn will invoke  CMake, and build the whole project. After this, you can then  also run the usual </p> <pre><code>make\nctest\n</code></pre>"},{"location":"developer_reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>approximation utils<ul> <li>approximating polynomials</li> </ul> </li> <li>approximations<ul> <li>polynomial approximations</li> </ul> </li> <li>gaussian<ul> <li>approximation</li> </ul> </li> <li>non central chi squared<ul> <li>approximate non central chi squared</li> <li>table coefficients</li> <li>approximation</li> </ul> </li> <li>type hints<ul> <li>arrays</li> </ul> </li> <li>version</li> </ul>"},{"location":"developer_reference/_approximation_utils/index.html","title":"approximation utils","text":"<p>Useful utilities for forming approximations.</p>"},{"location":"developer_reference/_approximation_utils/approximating_polynomials.html","title":"approximating polynomials","text":"<p>Some useful code to approximate inverse cumulative distribution functions to produce approximate random variables by the inverse transform method.</p>"},{"location":"developer_reference/_approximation_utils/approximating_polynomials.html#_approximation_utils.approximating_polynomials.dyadic_intervals_in_half_interval","title":"<code>dyadic_intervals_in_half_interval(n_intervals)</code>","text":"<p>Computed the dyadic intervals in [0, 1/2].</p> <p>Parameters:</p> Name Type Description Default <code>n_intervals</code> <code>int</code> <p>The number of intervals.</p> required <p>Returns:</p> Type Description <code>intervals</code> <p>The dyadic intervals. e.g. <code>[[1/2, 1/2], [1/4, 1/2], [1/8, 1/4], ... [0, 1/16]]</code></p> Source code in <code>src/pyarv/_approximation_utils/approximating_polynomials.py</code> <pre><code>def dyadic_intervals_in_half_interval(n_intervals: int) -&gt; list[list[float]]:\n    \"\"\"\n    Computed the dyadic intervals in [0, 1/2].\n\n    Parameters\n    ----------\n    n_intervals\n        The number of intervals. \n\n    Returns\n    -------\n    intervals\n        The dyadic intervals. e.g. `[[1/2, 1/2], [1/4, 1/2], [1/8, 1/4], ... [0, 1/16]]`\n    \"\"\"\n    intervals = [[0.5 ** (i + 1), 0.5 ** i] for i in range(n_intervals)]\n    intervals[0] = [0.5, 0.5]\n    intervals[-1][0] = 0.0\n    return intervals\n</code></pre>"},{"location":"developer_reference/_approximation_utils/approximating_polynomials.html#_approximation_utils.approximating_polynomials.optimal_polynomial_coefficients","title":"<code>optimal_polynomial_coefficients(*, f, polynomial_order, lower_limit, upper_limit)</code>","text":"<p>Calculates the  optimal coefficients of a polynomial approximation to a function .</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p> </p> required <code>polynomial_order</code> <code>int</code> <p>Order of the polynomial approximation.</p> required <code>lower_limit</code> <code>float</code> <p> </p> required <code>upper_limit</code> <code>float</code> <p> </p> required <p>Returns:</p> Type Description <code>coefficients</code> <p>Polynomial coefficients.</p> Source code in <code>src/pyarv/_approximation_utils/approximating_polynomials.py</code> <pre><code>def optimal_polynomial_coefficients(*,\n                                    f: Callable,\n                                    polynomial_order:int,\n                                    lower_limit:float,\n                                    upper_limit:float) -&gt; Array:\n    r\"\"\"\n    Calculates the \\( L^2 \\) optimal coefficients of a polynomial approximation to a function \\( f \\colon (a, b) \\to \\mathbb{R} \\).\n\n    Parameters\n    ----------\n    f\n        \\( f \\)\n    polynomial_order\n        Order of the polynomial approximation. \n    lower_limit\n        \\( a \\) \n    upper_limit\n        \\( b \\) \n\n    Returns\n    -------\n    coefficients\n        Polynomial coefficients. \n    \"\"\"\n    B = [_integrate(lambda u: u ** i * f(u), lower_limit, upper_limit) for i in range(polynomial_order + 1)]\n    A = [[(upper_limit ** (i + j + 1) - lower_limit ** (i + j + 1)) / (i + j + 1.0) for i in range(polynomial_order + 1)] for j in range(polynomial_order + 1)]\n    return solve(A, B)\n</code></pre>"},{"location":"developer_reference/_approximation_utils/approximating_polynomials.html#_approximation_utils.approximating_polynomials.piecewise_polynomial_coefficients_in_half_interval","title":"<code>piecewise_polynomial_coefficients_in_half_interval(f, n_intervals, polynomial_order)</code>","text":"<p>Computes the coefficients of a piecewise polynomial approximation to a function  using dyadic intervals in .</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p> .</p> required <code>n_intervals</code> <code>int</code> <p>The number of intervals.</p> required <code>polynomial_order</code> <code>int</code> <p>The polynomial order.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The polynomial coefficient tables.</p> Source code in <code>src/pyarv/_approximation_utils/approximating_polynomials.py</code> <pre><code>def piecewise_polynomial_coefficients_in_half_interval(f: Callable, \n                                                       n_intervals: int, \n                                                       polynomial_order: int) -&gt; Array:\n    \"\"\"\n    Computes the coefficients of a piecewise polynomial approximation to a function \\( f \\)\n    using dyadic intervals in \\( [0, 1/2] \\).\n\n    Parameters\n    ----------\n    f\n        \\( f \\). \n    n_intervals\n        The number of intervals. \n    polynomial_order\n        The polynomial order. \n\n    Returns\n    -------\n    Array\n        The polynomial coefficient tables. \n    \"\"\"\n    intervals = dyadic_intervals_in_half_interval(n_intervals)\n    coefficients = zeros((polynomial_order + 1, n_intervals))\n    for i in range(n_intervals):\n        a, b = intervals[i]\n        coefficients[:, i] = optimal_polynomial_coefficients(f=f, polynomial_order=polynomial_order, lower_limit=a, upper_limit=b) if a != b else f(b)\n    return coefficients\n</code></pre>"},{"location":"developer_reference/approximations/index.html","title":"approximations","text":"<p>The general framework for our approximations.</p>"},{"location":"developer_reference/approximations/polynomial_approximations.html","title":"polynomial approximations","text":"<p>The interface we specify for our approximations.</p>"},{"location":"developer_reference/approximations/polynomial_approximations.html#approximations.polynomial_approximations.PolynomialApproximationTransformer","title":"<code>PolynomialApproximationTransformer(*args, use_preallocated_output_array=False, order=1, cache_table=True, try_cached_table=True, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The general class all polynomial approximations should derive from.</p> <p>Create the transformer.</p> <p>Parameters:</p> Name Type Description Default <code>use_preallocated_output_array</code> <code>bool</code> <p>Whether to use a user provided array with preallocated memory.</p> <code>False</code> <code>order</code> <code>int</code> <p>The polynomial order.</p> <p>0 = constant. 1 = linear. 2 = quadratic. 3 = cubic. ... etc. ...</p> <code>1</code> <code>cache_table</code> <code>bool</code> <p>Should any coefficient tables be cached?</p> <code>True</code> <code>try_cached_table</code> <code>bool</code> <p>Should coefficient table caches be tried?</p> <code>True</code> Source code in <code>src/pyarv/approximations/polynomial_approximations.py</code> <pre><code>def __init__(self, \n             *args, \n             use_preallocated_output_array: bool=False,\n             order: int = 1,\n             cache_table: bool =True, \n             try_cached_table: bool =True,\n             **kwargs):\n    \"\"\"\n    Create the transformer.\n\n    Parameters\n    ----------\n    use_preallocated_output_array\n        Whether to use a user provided array with preallocated memory.\n    order\n        The polynomial order.\n\n        0 = constant.  \n        1 = linear.  \n        2 = quadratic.  \n        3 = cubic.  \n        ... etc. ...\n    cache_table\n        Should any coefficient tables be cached?\n    try_cached_table\n        Should coefficient table caches be tried? \n    \"\"\"\n    if order &lt; 0:\n        raise ValueError(f\"The polynomial order must be positive, not {order = }\")\n    if not isinstance(use_preallocated_output_array, bool):\n        raise ValueError(f\"A boolean value must be specified, not {use_preallocated_output_array = }\")\n    if not isinstance(cache_table, bool):\n        raise ValueError(f\"A boolean value must be specified, not {cache_table = }\")\n    if not isinstance(try_cached_table, bool):\n        raise ValueError(f\"A boolean value must be specified, not {try_cached_table = }\")\n    self.use_preallocated_output_array = use_preallocated_output_array\n    self.cache_table = cache_table\n    self.try_cached_table = try_cached_table\n    self.order = order\n</code></pre>"},{"location":"developer_reference/approximations/polynomial_approximations.html#approximations.polynomial_approximations.PolynomialApproximationTransformer.approximation","title":"<code>approximation(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>The underlying approximation and the interface between the Python and C functions. This may have additional parameters beyond those  described by <code>transform</code>. (Also responsible for generating coefficient tables and caching).</p> Source code in <code>src/pyarv/approximations/polynomial_approximations.py</code> <pre><code>@abc.abstractmethod\ndef approximation(self,\n                  *args,\n                  **kwargs) -&gt; None:\n    \"\"\"\n    The underlying approximation and the interface between the Python\n    and C functions. This may have additional parameters beyond those \n    described by `transform`. (Also responsible for generating coefficient tables\n    and caching). \n    \"\"\"\n    ...\n</code></pre>"},{"location":"developer_reference/approximations/polynomial_approximations.html#approximations.polynomial_approximations.PolynomialApproximationTransformer.transform","title":"<code>transform(inputs, /, *, outputs=None, **kwargs)</code>","text":"<p>Use a polynomial approximation for the inverse transform method.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Array</code> <p>Uniform random numbers in .</p> required <code>outputs</code> <code>Array | None</code> <p>A pre-allocated array containing the outputs if requested.</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments needed for any specific distribution's <code>approximation</code> implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>outputs</code> <code>Array | None</code> <p>Random variables from a desired distribution.</p> Source code in <code>src/pyarv/approximations/polynomial_approximations.py</code> <pre><code>def transform(self, \n               inputs: Array, \n               /, \n               *, \n               outputs: Array | None = None, \n               **kwargs: dict[str, Any])\\\n        -&gt; Array | None:\n    \"\"\"\n    Use a polynomial approximation for the inverse transform method.\n\n    Parameters\n    ----------\n    inputs\n        Uniform random numbers in \\( [0, 1] \\). \n    outputs\n        A pre-allocated array containing the outputs if requested. \n    kwargs\n        Keyword arguments needed for any specific distribution's `approximation` implementation. \n\n    Returns\n    -------\n    outputs:\n        Random variables from a desired distribution. \n\n    \"\"\"\n    if self.use_preallocated_output_array:\n        if len(inputs) != len(outputs):\n            raise TypeError(f\"The {outputs = } must be the same length as the {inputs = }\")\n        if outputs.shape != inputs.shape:\n            raise TypeError(f\"The {outputs.shape} must match the {inputs.shape}\")\n        if not inputs.flags['C_CONTIGUOUS']:\n            raise TypeError(f\"The {inputs = } must be C-contiguous.\")\n        if not outputs.flags['C_CONTIGUOUS']:\n            raise TypeError(f\"The {outputs = } must be C-contiguous.\")\n        if inputs.dtype != np.float32:\n            raise TypeError(f\"The {inputs.dtype = } must be {np.float32}.\")\n        if outputs.dtype != inputs.dtype:\n            raise TypeError(f\"The {outputs.dtype = } must match {inputs.dtype = }.\")\n        if outputs is inputs:\n            raise ValueError(f\"Must use different objects for output, {inputs is outputs = }\")\n        if outputs.base is inputs or inputs.base is outputs:\n            raise ValueError(f\"The inputs and output arrays must not share any memory.\")\n\n    if not self.use_preallocated_output_array:\n        if outputs is not None:\n            raise ValueError(f\"{self.use_preallocated_output_array = }, but {outputs = } has been provided.\")\n        outputs = np.empty_like(inputs)\n\n    self.approximation(inputs=inputs, outputs=outputs, order=self.order, **kwargs)\n    return outputs\n</code></pre>"},{"location":"developer_reference/gaussian/index.html","title":"gaussian","text":"<p>The Gaussian distribution, a.k.a. the Normal distribution.</p>"},{"location":"developer_reference/gaussian/approximation.html","title":"approximation","text":""},{"location":"developer_reference/gaussian/approximation.html#gaussian.approximation.Gaussian","title":"<code>Gaussian</code>","text":"<p>               Bases: <code>PolynomialApproximationTransformer</code></p> <p>Polynomial approximation to the inverse CDF of the Gaussian distribution,  .</p>"},{"location":"developer_reference/non_central_chi_squared/index.html","title":"non central chi squared","text":"<p>The non-central  distribution.</p>"},{"location":"developer_reference/non_central_chi_squared/_approximate_non_central_chi_squared.html","title":"approximate non central chi squared","text":""},{"location":"developer_reference/non_central_chi_squared/_approximate_non_central_chi_squared.html#non_central_chi_squared._approximate_non_central_chi_squared.construct_inverse_non_central_chi_squared_interpolated_polynomial_approximation","title":"<code>construct_inverse_non_central_chi_squared_interpolated_polynomial_approximation(degrees_of_freedom, polynomial_order=1, n_intervals=16, n_interpolating_functions=16)</code>","text":"<p>Computes a polynomial approximation to the inverse cumulative distribution function for the non-central  distribution for a fixed number of degrees of freedom . The approximation is parametrised by a non-centrality parameter .</p> <p>Parameters:</p> Name Type Description Default <code>degrees_of_freedom</code> <code>float</code> <p>The degrees of freedom .</p> required <code>polynomial_order</code> <code>int</code> <p>The polynomial order.</p> <code>1</code> <code>n_intervals</code> <code>int</code> <p>The number of intervals.</p> <code>16</code> <code>n_interpolating_functions</code> <code>int</code> <p>The number of interpolating functions for interpolating the non-centrality parameter .</p> <code>16</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The approximation.</p> Source code in <code>src/pyarv/non_central_chi_squared/_approximate_non_central_chi_squared.py</code> <pre><code>def construct_inverse_non_central_chi_squared_interpolated_polynomial_approximation(degrees_of_freedom: float,\n                                                                                    polynomial_order: int =1,\n                                                                                    n_intervals: int =16,\n                                                                                    n_interpolating_functions:int =16) -&gt; Callable:\n    r\"\"\"\n    Computes a polynomial approximation to the inverse cumulative distribution function for the non-central\n    \\( \\chi^2 \\) distribution for a fixed number of degrees of freedom \\( \\nu \\). The approximation is parametrised\n    by a non-centrality parameter \\( \\lambda \\).\n\n    Parameters\n    ----------\n    degrees_of_freedom\n        The degrees of freedom \\( \\nu \\).\n    polynomial_order\n        The polynomial order. \n    n_intervals\n        The number of intervals. \n    n_interpolating_functions\n        The number of interpolating functions for interpolating the non-centrality parameter \\( \\lambda \\). \n\n    Returns\n    -------\n    Callable\n        The approximation. \n    \"\"\"\n    interpolation_function = lambda f: f ** 0.5\n    interpolation_function_deriv_first = lambda f: 0.5 * f ** -0.5\n    interpolation_function_deriv_second = lambda f: -0.25 * f ** -1.5\n\n    interpolation_function_contour_spacing = 1.0 / (n_interpolating_functions - 1)\n    interpolation_values = ([interpolation_function(1.0) - n * interpolation_function_contour_spacing for n in range(n_interpolating_functions - 1)] + [interpolation_function(0)])[::-1]  # interpolation key values\n    interpolation_points = [0.0] + [root_scalar(lambda a: interpolation_function(a) - y, x0=0.5, bracket=[0.0, 1.0], fprime=interpolation_function_deriv_first, fprime2=interpolation_function_deriv_second).root for y in interpolation_values[1:-1]] + [1.0]  # non-centrality for interpolating functions\n    # We approximate the function P\n    functions_exact = [None] * n_interpolating_functions  # The exact functions\n    functions_exact[0] = norm.ppf  # Limiting case as y -&gt; 0\n    # The following odd syntax with y=... ensures y is evaluated at declaration and not taken by reference:\n    functions_exact[1:-1] = [lambda u, y=y_interpolation_points: np.sqrt(degrees_of_freedom / (4.0 * y)) * (y / degrees_of_freedom * ncx2.ppf(u, df=degrees_of_freedom, nc=(1.0 - y) * degrees_of_freedom / y) - 1.0) for y_interpolation_points in interpolation_points[1:-1]]\n    functions_exact[-1] = lambda u: np.sqrt(degrees_of_freedom / 4.0) * (chi2.ppf(u, df=degrees_of_freedom) / degrees_of_freedom - 1.0)\n    functions_approx = [dyadic_function_approximation_constructor(f, n_intervals, polynomial_order) for f in progressbar(functions_exact)]  # By piecewise dyadic construction\n\n    def construct_linear_interpolation(functions: tuple[Callable, Callable], \n                                       weightings: tuple[float, float]):\n        \"\"\"\n        Builds a linear interpolation between two functions.\n        \"\"\"\n        f1, f2 = functions\n        w1, w2 = weightings\n        return lambda u: f1(u) * w1 + f2(u) * w2\n\n    def get_interpolation_functions_and_weightings(non_centrality: float):\n        \"\"\"\n        Determines the interpolation functions to use and their weights.\n        \"\"\"\n        interpolation_value = interpolation_function(non_centrality)\n        insertion_index = bisect(interpolation_values, interpolation_value, lo=0)\n        lower_index, upper_index = insertion_index - 1, insertion_index\n        assert lower_index &gt;= 0\n        assert upper_index &lt;= len(interpolation_values)\n        if upper_index == len(interpolation_values):\n            return [[functions_approx[lower_index]] * 2, [1.0, 0.0]]\n        functions = [functions_approx[i] for i in [lower_index, upper_index]]\n        interpolation_lower, interpolation_upper = [interpolation_values[i] for i in [lower_index, upper_index]]\n        w_lower = (interpolation_upper - interpolation_value) / (interpolation_upper - interpolation_lower)\n        w_upper = 1.0 - w_lower\n        weights = [w_lower, w_upper]\n        return [functions, weights]\n\n    def inverse_non_central_chi_squared_interpolated_polynomial_approximation(u: Array, non_centrality: float):\n        \"\"\"\n        Polynomial approximation to the inverse cumulative distribution function for the non-central\n        \\( \\chi^2 \\) distribution\n        \"\"\"\n        functions, weightings = get_interpolation_functions_and_weightings(degrees_of_freedom / (non_centrality + degrees_of_freedom))\n        interpolated_function = construct_linear_interpolation(functions, weightings)\n        return non_centrality + degrees_of_freedom + 2.0 * np.sqrt(non_centrality + degrees_of_freedom) * interpolated_function(u)\n\n    return inverse_non_central_chi_squared_interpolated_polynomial_approximation\n</code></pre>"},{"location":"developer_reference/non_central_chi_squared/_approximate_non_central_chi_squared.html#non_central_chi_squared._approximate_non_central_chi_squared.dyadic_function_approximation_constructor","title":"<code>dyadic_function_approximation_constructor(f, n_intervals, polynomial_order)</code>","text":"<p>Constructs a piecewise polynomial approximation to a function   which is piecewise  optimal on dyadic intervals on each of  and .</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p> .</p> required <code>n_intervals</code> <code>int</code> <p>The number of intervals.</p> required <code>polynomial_order</code> <code>int</code> <p>The polynomial order.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The approximations.</p> Source code in <code>src/pyarv/non_central_chi_squared/_approximate_non_central_chi_squared.py</code> <pre><code>def dyadic_function_approximation_constructor(f: Callable, n_intervals: int, polynomial_order:int) -&gt; Callable:\n    r\"\"\"\n    Constructs a piecewise polynomial approximation to a function \\( f \\)  which is piecewise\n    \\( L^2 \\) optimal on dyadic intervals on each of \\( [0, \\tfrac{1}{2} ) \\) and \\( [\\tfrac{1}{2}, 1] \\).\n\n    Parameters\n    ----------\n    f\n        \\( f \\).\n    n_intervals\n        The number of intervals.\n    polynomial_order\n        The polynomial order. \n\n    Returns\n    -------\n    Callable\n        The approximations.\n    \"\"\"\n    f_lower = f\n    f_upper = lambda u, *args, **kwargs: f(1.0 - u, *args, **kwargs)\n    coeffs_lower = piecewise_polynomial_coefficients_in_half_interval(f_lower, n_intervals, polynomial_order)\n    coeffs_upper = piecewise_polynomial_coefficients_in_half_interval(f_upper, n_intervals, polynomial_order)\n    index_of_dyadic_interval = construct_index_of_dyadic_interval(n_intervals)\n\n    def inverse_cumulative_distribution_function_approximation(u):\n        \"\"\"\n        Polynomial approximation of the inverse cumulative distribution function.\n        \"\"\"\n        in_lower = (u &lt; 0.5)\n        u = u * in_lower + np.logical_not(in_lower) * (1.0 - u)\n        interval = index_of_dyadic_interval(u)\n        y_lower, y_upper = [sum([coeffs[i][interval] * u ** i for i in range(polynomial_order + 1)]) for coeffs in [coeffs_lower, coeffs_upper]]\n        y = y_lower * in_lower + y_upper * np.logical_not(in_lower)\n        return y\n\n    return inverse_cumulative_distribution_function_approximation\n</code></pre>"},{"location":"developer_reference/non_central_chi_squared/_table_coefficients.html","title":"table coefficients","text":""},{"location":"developer_reference/non_central_chi_squared/_table_coefficients.html#non_central_chi_squared._table_coefficients.generate_non_central_chi_squared_coefficients","title":"<code>generate_non_central_chi_squared_coefficients(*, n_intervals, n_interpolation_functions, n_polynomial_orders, dof, dtype=np.float32)</code>","text":"<p>Generate coefficient tables for the non-central  distribution.</p> Source code in <code>src/pyarv/non_central_chi_squared/_table_coefficients.py</code> <pre><code>def generate_non_central_chi_squared_coefficients(*,\n    n_intervals: int,\n    n_interpolation_functions: int,\n    n_polynomial_orders: int,\n    dof: float,\n    dtype: type = np.float32\n    ) -&gt; Array:\n    \"\"\"\n    Generate coefficient tables for the non-central \\( \\chi^2 \\) distribution.\n    \"\"\"\n    n_halves=2\n    lower_half, upper_half = [0, 1]\n    polynomial_order = n_polynomial_orders - 1\n\n    n_entries = n_halves * n_interpolation_functions * n_polynomial_orders * n_intervals\n    polynomial_coefficients = np.reshape([None] * n_entries,\n                                         shape=(n_halves,\n                                                n_interpolation_functions,\n                                                n_polynomial_orders,\n                                                n_intervals))\n\n\n    interpolation_function = lambda f: f ** 0.5\n    interpolation_function_deriv_first = lambda f: 0.5 * f ** -0.5\n    interpolation_function_deriv_second = lambda f: -0.25 * f ** -1.5\n\n    interpolation_function_contour_spacing = 1.0 / (n_interpolation_functions - 1)\n    interpolation_values = ([interpolation_function(1.0) - n * interpolation_function_contour_spacing for n in range(n_interpolation_functions - 1)] + [interpolation_function(0)])[::-1]  # interpolation key values\n    interpolation_points = [0.0] + [root_scalar(lambda a: interpolation_function(a) - y, x0=0.5, bracket=[0.0, 1.0], fprime=interpolation_function_deriv_first, fprime2=interpolation_function_deriv_second).root for y in interpolation_values[1:-1]] + [1.0]  # non-centrality for interpolating functions\n    # We approximate the function P\n    functions_exact = [None] * n_interpolation_functions  # The exact functions\n    functions_exact[0] = norm.ppf  # Limiting case as y -&gt; 0\n    # The following odd syntax with y=... ensures y is evaluated at declaration and not taken by reference:\n    functions_exact[1:-1] = [lambda u, y=y_interpolation_points: np.sqrt(dof / (4.0 * y)) * (y / dof * ncx2.ppf(u, df=dof, nc=(1.0 - y) * dof / y) - 1.0) for y_interpolation_points in interpolation_points[1:-1]]\n    functions_exact[-1] = lambda u: np.sqrt(dof / 4.0) * (chi2.ppf(u, df=dof) / dof - 1.0)\n\n\n    for interpolation_function_index, exact_function in enumerate(functions_exact):\n        f_lower = exact_function\n        f_upper = lambda u, *args, **kwargs: f_lower(1.0 - u, *args, **kwargs)\n        coeffs_lower = piecewise_polynomial_coefficients_in_half_interval(f_lower, n_intervals, polynomial_order)\n        coeffs_upper = piecewise_polynomial_coefficients_in_half_interval(f_upper, n_intervals, polynomial_order)\n        polynomial_coefficients[lower_half][interpolation_function_index] = coeffs_lower\n        polynomial_coefficients[upper_half][interpolation_function_index] = coeffs_upper\n\n    assert all([i is not None for i in polynomial_coefficients.flatten()]), f\"The polynomial coefficients contain a missing value.\"\n    return np.ascontiguousarray(polynomial_coefficients.flatten(order=\"C\"), dtype=dtype)\n</code></pre>"},{"location":"developer_reference/non_central_chi_squared/approximation.html","title":"approximation","text":""},{"location":"developer_reference/non_central_chi_squared/approximation.html#non_central_chi_squared.approximation.NonCentralChiSquared","title":"<code>NonCentralChiSquared(*args, **kwargs)</code>","text":"<p>               Bases: <code>PolynomialApproximationTransformer</code></p> <p>Polynomial approximation to the inverse CDF of the non-central  distribution.</p> Source code in <code>src/pyarv/non_central_chi_squared/approximation.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.cached_tables = {}\n</code></pre>"},{"location":"developer_reference/non_central_chi_squared/approximation.html#non_central_chi_squared.approximation.NonCentralChiSquared.approximation","title":"<code>approximation(*args, order, non_centralities, degrees_of_freedom, **kwargs)</code>","text":"<p>Specialism extending <code>PolynomialApproximationTransformer.transform</code>.</p> <p>Parameters:</p> Name Type Description Default <code>non_centralities</code> <code>Array</code> <p>The non-centralities, positive (zero values correspond to the central  distribution).</p> required <code>degrees_of_freedom</code> <code>float</code> <p>The degrees of freedom, strictly positive, assumed to be fixed for all values.</p> required Source code in <code>src/pyarv/non_central_chi_squared/approximation.py</code> <pre><code>def approximation(self, \n               *args,\n               order,\n               non_centralities: Array,\n               degrees_of_freedom: float,\n               **kwargs\n               ):\n    r\"\"\"\n    Specialism extending `PolynomialApproximationTransformer.transform`.\n\n    Parameters\n    ----------\n    non_centralities:\n        The non-centralities, positive (zero values correspond to the central \\( \\chi^2 \\) distribution).\n    degrees_of_freedom:\n        The degrees of freedom, strictly positive, assumed to be fixed for all values.    \n    \"\"\"\n    approximations = {1: linear}\n    if self.order not in approximations.keys():\n        raise NotImplementedError(f\"We have not yet implemented interfaced for higher order approximations. Currently we only support orders: {approximations.keys()}\")\n    polynomial_coefficients = None\n    if self.try_cached_table:\n        try:\n            polynomial_coefficients = self.cached_tables[degrees_of_freedom]\n        except KeyError:\n            logging.info(f\"There were no cached coefficients for {degrees_of_freedom = }\")\n    if polynomial_coefficients is None:\n        logging.info(f\"Generating coefficients for {degrees_of_freedom = }\")\n        polynomial_coefficients = generate_non_central_chi_squared_coefficients(n_intervals=16,\n                                                                                n_interpolation_functions=16,\n                                                                                n_polynomial_orders=self.order+1,\n                                                                                dof=degrees_of_freedom,\n                                                                                dtype=np.float32\n                                                                                )\n    assert polynomial_coefficients is not None\n    if self.cache_table:\n        logging.info(f\"Caching the coefficients for {degrees_of_freedom = }\")\n        self.cached_tables[degrees_of_freedom] = polynomial_coefficients\n    approximations[self.order](*args,\n                           non_centralities=non_centralities,\n                           degrees_of_freedom=degrees_of_freedom,\n                           polynomial_coefficients=polynomial_coefficients,\n                           **kwargs)\n</code></pre>"},{"location":"developer_reference/type_hints/index.html","title":"type hints","text":""},{"location":"developer_reference/type_hints/arrays.html","title":"arrays","text":""},{"location":"developer_reference/type_hints/arrays.html#type_hints.arrays.Array","title":"<code>Array = Annotated[npt.NDArray[np.float32], Literal['N']]</code>  <code>module-attribute</code>","text":"<p>The array type.</p>"},{"location":"developer_reference/version/index.html","title":"version","text":"<p>Version information.</p>"},{"location":"developer_reference/version/index.html#version.__version__","title":"<code>__version__: str</code>  <code>module-attribute</code>","text":"<p>The repo's version</p>"},{"location":"getting_started/an_example.html","title":"An example","text":"<p>The example showcases how to use the PyARV package.</p> <p>NumPy arrays</p> <ul> <li>We use numpy arrays, not lists. </li> <li>The arrays have a specific datatype, in this case <code>np.float32</code>.</li> <li>The function needs a preallocated location to write its results into.</li> </ul> <pre><code>import numpy as np\nfrom pyarv.gaussian.approximation import Gaussian\n\nn_samples = 10_000_000\nu = np.random.uniform(size=n_samples + 1).astype(np.float32)\nz_approx = Gaussian(order=1).transform(u)\nprint(f\"{z_approx = }\")\n</code></pre> <p>To see how much faster PyARV is on your system, run:</p> <pre><code>python -m pyarv.gaussian.demos.speed\npython -m pyarv.non_central_chi_squared.demos.speed\n</code></pre>"},{"location":"getting_started/dependencies.html","title":"Dependencies","text":""},{"location":"getting_started/dependencies.html#python","title":"Python","text":"<p>For the core routines you will require. </p> <ul> <li>Python 3.12 or newer, (only because we use the latest nested f-string features).</li> <li>NumPy.</li> </ul> <p>To run the demos, plots, or speed tests, then you will need  some extra packages, and some notable mentions include:</p> <ul> <li><code>tqdm</code>.</li> <li>SciPy.</li> <li>Matplotlib.</li> </ul>"},{"location":"getting_started/dependencies.html#c","title":"C","text":"<ul> <li>A C99 compiler supporting <code>-fopenmp</code>.</li> <li>OpenMP support. </li> </ul>"},{"location":"getting_started/dependencies.html#other","title":"Other","text":"<p>Some of the other tools you will need include:</p> <ul> <li>CMake.</li> <li>Git.</li> <li>A POSIX filesystem. </li> </ul>"},{"location":"getting_started/installation.html","title":"Installation","text":"<p>To install the most recent release run:</p> <pre><code>pip install pyarv\n</code></pre> <p>or to install the latest version run:</p> <pre><code>pip install git+https://github.com/oliversheridanmethven/pyarv.git\n</code></pre> <p>To test the installation is working fine run:</p> <pre><code>pytest --pyargs pyarv\n</code></pre>"},{"location":"getting_started/installation.html#common-installation-issues","title":"Common installation issues","text":""},{"location":"getting_started/installation.html#apple-clang-does-not-support-fopenmp","title":"Apple Clang does not support <code>-fopenmp</code>","text":"<p>Apple Clang does not support <code>-fopenmp</code> out of the box, but a simple <code>brew install [gcc|llvm]</code> resolves this issue by installing a nice new compiler which does support the flag.  If you are required to use the native Apple Clang compiler, then doing <code>brew reinstall libomp</code> should circumvent the issue.</p>"},{"location":"getting_started/installation.html#gcc-on-mac-complains-about-missing-definitions-and-unknown-types-from-stdioh","title":"GCC on Mac complains about missing definitions and unknown types from <code>stdio.h</code>","text":"<p>Trying to use modern versions of GCC (e.g. 14.2)  on Mac complains about missing standard library functions, types, and definitions from <code>stdio.h</code>, such as: <code>error: unknown type name 'FILE'</code> </p> <p>There is an incompatability between CMake, Mac, XCode, and GCC, which is documented here with a MWE. A solution to this is to</p> <pre><code>export SDKROOT=/Library/Developer/CommandLineTools/SDKs/MacOSX14.sdk/\n</code></pre> <p>before calling CMake. Note that newer versions of the SDK, such as 15, still exhibit this issue. (Perhaps put this in your <code>~/.bashrc</code>, <code>~/.zshrc</code>, or similar.)</p>"},{"location":"release_history/change_log.html","title":"Change log","text":""},{"location":"release_history/change_log.html#version-01","title":"Version 0.1","text":"<p>When there is a version 0.1, this section will be updated.</p>"},{"location":"release_history/upcoming_features.html","title":"Upcoming features","text":"<p>Here we sketch out some of the milestones we would like to achieve and a collection of our higher level ambitions from this project.</p>"},{"location":"release_history/upcoming_features.html#motivation","title":"Motivation","text":"<p>This project is currently constructed primarily as a learning exercise. While we hope it picks up traction and becomes wildly popular, that is not our primary goal. Our aim is to use this as a development testbed for documentation generation, repository hosting, testing frameworks, PyPI deployment, build system integration with <code>pip</code> and CMake (or e.g. Bazel), type hinting, sanitisers, etc.   </p>"},{"location":"release_history/upcoming_features.html#versions","title":"Versions","text":""},{"location":"release_history/upcoming_features.html#release-0","title":"Release 0","text":""},{"location":"release_history/upcoming_features.html#01","title":"0.1","text":"<ul> <li>A first working draft of a Python interface that can be installed using  pip from PyPI or from a git clone of the repo.  </li> <li>The Gaussian distribution:</li> <li>Linear and cubic approximations for appropriate pre-specified table sizes. </li> </ul>"},{"location":"release_history/upcoming_features.html#02","title":"0.2","text":"<ul> <li>The non-central  distribution. </li> <li>Better documentation including a user guide, developer guide, examples, etc. </li> </ul>"},{"location":"release_history/upcoming_features.html#03","title":"0.3","text":"<ul> <li>Other distributions such as: Poisson, Beta, , etc. </li> </ul>"},{"location":"release_history/upcoming_features.html#release-1","title":"Release 1","text":"<p>Once these checkpoint have been achieved we will be ready to  release this as version 1.0. </p>"},{"location":"release_history/upcoming_features.html#release-2","title":"Release 2","text":"<p>For version 2.0, we want to split out the C implementation into its  own repo and have it as a submodule (or similar) in this repo.  Thereafter, the two repos will be two separate projects. </p>"}]}