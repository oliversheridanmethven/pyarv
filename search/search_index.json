{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"PyARV","text":"<p>Python wrapper of a C implementation of approximate random variables as detailed in:</p> <p>Michael B. Giles and Oliver Sheridan-Methven.  Approximating inverse cumulative distribution functions to produce approximate random variables.  ACM Transactions on Mathematical Software, 49(3), Article 26, September 2023, 29 pages.  https://doi.org/10.1145/3604935</p>"},{"location":"index.html#authors","title":"Authors","text":"<p>Dr Oliver Sheridan-Methven oliver.sheridan-methven@hotmail.co.uk.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The full documentation can be found here: Documentation.</p>"},{"location":"LICENSE.html","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Dr Oliver Sheridan-Methven</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"developer_notes/upcoming_features.html","title":"Upcoming features","text":"<p>Here we sketch out some of the milestone we would like to achieve and a collection of our higher level ambitions from this project.</p>"},{"location":"developer_notes/upcoming_features.html#motivation","title":"Motivation","text":"<p>This project is currently constructed as a learning exercise. While we hope it picks up traction and becomes wildly popular, that is not our primary goal. Our aim is to use this as a development testbed for documentation generation, repository hosting, testing frameworks, PyPI deployment, build system integration with pip and CMake (or e.g. Bazel), type hinting and sanitisers, etc.   </p>"},{"location":"developer_notes/upcoming_features.html#versions","title":"Versions","text":""},{"location":"developer_notes/upcoming_features.html#release-0","title":"Release 0","text":""},{"location":"developer_notes/upcoming_features.html#01","title":"0.1","text":"<ul> <li>A first working draft of a Python interface that can be installed using  pip from PyPI or from a git clone of the repo.  </li> <li>The Gaussian distribution:</li> <li>Linear and cubic approximations for appropriate pre-specified table sizes. </li> </ul>"},{"location":"developer_notes/upcoming_features.html#02","title":"0.2","text":"<ul> <li>The non-central  distribution. </li> <li>Better documentation including a user guide, developer guide, examples, etc. </li> </ul>"},{"location":"developer_notes/upcoming_features.html#03","title":"0.3","text":"<ul> <li>Other distributions such as: Poisson, Beta, etc. </li> </ul>"},{"location":"developer_notes/upcoming_features.html#release-1","title":"Release 1","text":"<p>Once these checkpoint have been achieved we will be ready to  release this as version 1.0. </p>"},{"location":"developer_notes/upcoming_features.html#release-2","title":"Release 2","text":"<p>For version 2.0, we want to split out the C implementation into its  own repo and have it as a submodule (or similar) in this repo.  Thereafter, the two repos will be two separate projects. </p>"},{"location":"developer_notes/updating_versions_and_releases_and_documentation.html","title":"Updating the git versions and releases","text":"<p>To list the git version tags: </p> <pre><code>git tag -l\n</code></pre> <p>To list the git version tags along with a brief 1-line description (<code>-n&lt;K&gt;</code> for <code>K</code> lines):</p> <pre><code>git tag -l -n1\n</code></pre> <p>To add a tag use:</p> <pre><code>git tag -a &lt;vX.Y.Z&gt; -m \"&lt;SOME BRIEF MESSAGE&gt;\"\n</code></pre> <p>The tag then needs to be pushed:</p> <pre><code>git push --tags\n</code></pre> <p>To set a release with a tag:</p> <pre><code>gh release create $(git describe --tags --abbrev=0)\n</code></pre>"},{"location":"developer_notes/updating_versions_and_releases_and_documentation.html#updating-the-remote-documentation","title":"Updating the remote documentation.","text":"<p>To update the documentation hosted remotely (e.g. on GitHub Pages),  then on <code>master</code> we need to redeploy the documents after  the most relevant commit by calling:</p> <pre><code>mkdocs gh-deploy --clean\n</code></pre>"},{"location":"developer_notes/why_python_and_c.html","title":"Why Python and C?","text":"<p>This project is a Python wrapper of C implementations. </p>"},{"location":"developer_notes/why_python_and_c.html#why-python","title":"Why Python?","text":"<p>It's the original author's favourite language, so it seemed a reasonable choice (as good as any other).</p>"},{"location":"developer_notes/why_python_and_c.html#why-c","title":"Why C?","text":"<p>The original ACM TOMS paper provides mathematical recipes for producing approximate random numbers, and the speed improvements derive from exploiting SIMD hardware. To go down to such a low-level brings us to the realms of the usual compiled HPC languages such as  C, C++, Fortran, Rust, etc. The original author didn't know  Fortran or Rust very well, so that left us with C or C++. </p> <p>Choosing between C and C++ was a hard decision, and either  would be a good platform to implement the underlying routines.  So why C and not C++:</p> <ul> <li>The approximation uses some type punning (between <code>int</code> and <code>float</code>),  and this is  easily done in C using unions (and is defined behaviour),  whereas in C++ type punning is much trickier to do correctly. </li> <li>C has the keyword <code>restrict</code> which does not exist in C++ without  compiler extensions (which we would prefer to avoid for portability), and this is something we take advantage of for optimisation.</li> <li>C is the lingua franca for HPC and portability, e.g. NumPy has a C API. </li> <li>The original author slightly prefers C.</li> </ul>"},{"location":"developer_notes/why_python_and_c.html#why-not-c-fortran-rust-julia-matlab-javascript-etc","title":"Why not C++, Fortran, Rust, Julia, MATLAB, JavaScript, etc.","text":"<p>Creating interfaces for the various languages should be easy enough, and if the package proves popular we welcome contributions to help us wide the scope.</p> <p>For the higher level languages we hope to wrap our C code similar to how we have for Python. For the lower level languages, either wrappers, re-implement in the preferred language, or use the  langauge feature, such as e.g. C++'s <code>extern \"C\"</code>. </p>"},{"location":"developer_notes/build_instructions/from_source.html","title":"Building from source","text":""},{"location":"developer_notes/build_instructions/from_source.html#out-of-source-builds","title":"Out-of-source builds","text":"<p>We follow the CMake convention by only encouraging \"out-of-source\" builds, hence the reason for this build directory existing. This directory exists only for manual building and testing with <code>cmake</code> et al.</p> <p>To build the project:</p> <pre><code>cd build\ncmake .. \nmake \npip3 install .. \nctest \n</code></pre> <p>!!! note     <code>make test</code> and <code>ctest</code> are synonymous.</p> <p>!!! note \"Running things in parallel\"     <code>cmake</code>, <code>ctest</code>, and <code>make</code> can all use multiple cores,      to speed things up, typically by adding a <code>-j &lt;N&gt;</code> or      <code>--parallel &lt;N&gt;</code> flag. </p> <p>The reason we install the Python package is because many of our tests are Python based as well, including several  C extensions and various Python modules we have created.  Hence, without this step, the various Python imports won't work correctly and many of the tests can be expected to fail. </p>"},{"location":"developer_notes/build_instructions/from_source.html#modern-c23-compilers","title":"Modern C23 compilers","text":"<p>We are trying to use a very modern C standard (C23 is brand new at the time of writing), and compiler support for this is very limited. To ensure <code>cmake</code> can find a sufficiently new compiler version, it may be necessary to hardwire paths to these in your invocation of <code>cmake</code>, e.g.:</p> <pre><code>cmake -D CMAKE_C_COMPILER=/usr/local/Cellar/gcc/13.1.0/bin/gcc-13 -D CMAKE_CXX_COMPILER=/usr/local/Cellar/gcc/13.1.0/bin/g++-13 ..\n</code></pre>"},{"location":"developer_notes/build_instructions/from_source.html#debugging","title":"Debugging","text":"<p>If any tests are failing, then these can be debugged further by running</p> <pre><code>ctest --rerun-failed --output-on-failure\n</code></pre>"},{"location":"developer_notes/build_instructions/in_source.html","title":"In source builds","text":""},{"location":"developer_notes/build_instructions/in_source.html#why-allow-in-source-builds","title":"Why allow in source builds?","text":"<p>In source builds are largely discouraged, and are only  recommended for use by developers. The reason we support this  for developers is to populate the source directory with various  generated files, libraries, etc. The use of this is for example: placing python extension libraries in the source directory.  This allowed for them to be picked up by an interpreter which can point to the in source code, rather than what is  produced by the scikit build procedure. This means code which is under development can be more easily accessed by an IDE or interpreter. </p>"},{"location":"developer_notes/build_instructions/in_source.html#making-in-source-builds","title":"Making in source builds","text":"<p>From the projects root directory run </p> <pre><code>cmake .\nmake \nmake install\nmake test \n</code></pre> <p>!!! note      This is run from the project's root directory, not from a      separate dedicated build directory.</p>"},{"location":"developer_notes/build_instructions/in_source.html#cleaning-everything-up","title":"Cleaning everything up","text":"<p>To clean everything up, run </p> <pre><code>make clean\n./cmake_uninstall.sh\n</code></pre>"},{"location":"developer_notes/build_instructions/in_source.html#adjusting-your-pythonpath","title":"Adjusting your <code>PYTHONPATH</code>","text":"<p>If you plan on testing out the code using the source code in  the repository, such as for use in a terminal setting or an  IDE, then it might be useful to add the contents of <code>src/</code> to your <code>PYTHONPATH</code> environment variable. To do just this we have the script <code>add_src_to_python_path.sh</code> which can be run  from the project's root directory by calling:</p> <pre><code>source add_src_to_python_path.sh\n</code></pre>"},{"location":"developer_notes/build_instructions/python_bindings.html","title":"Python bindings","text":"<p>We have setup this project to wrap some of the various C/C++ libraries with Python bindings. To install these, run</p> <pre><code>cd build\npip3 install ..\n</code></pre> <p>This will call <code>scikit-build</code>, which in turn will invoke  CMake, and build the whole project. After this, you can then  also run the usual </p> <pre><code>make\nctest\n</code></pre>"},{"location":"user_documentation/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>arv<ul> <li>gaussian<ul> <li>make_polynomial_coefficients</li> </ul> </li> </ul> </li> <li>pyarv<ul> <li>gaussian<ul> <li>polynomial</li> </ul> </li> </ul> </li> </ul>"},{"location":"user_documentation/arv/gaussian/make_polynomial_coefficients.html","title":"make_polynomial_coefficients","text":""},{"location":"user_documentation/arv/gaussian/make_polynomial_coefficients.html#arv.gaussian.make_polynomial_coefficients.fit_polynomal_approx_coefficients","title":"<code>fit_polynomal_approx_coefficients(*, poly_order, n_fit, table_size)</code>","text":"<p>Find the coefficients of the polynomial approximation of the inverse Gaussian CDF by a least squares polynomial fit.</p> <p>Parameters:</p> Name Type Description Default <code>poly_order</code> <code>int</code> <p>Order of polynomial.</p> required <code>n_fit</code> <code>int</code> <p>The number of points to sample in dyadic (exponentially distributed) to fit polynomial.</p> required <code>table_size</code> <code>int</code> <p>The number of entries in the resulting table.</p> required <p>Returns:</p> Name Type Description <code>Coefficients</code> <code>NDArray</code> <p>The polynomial coefficients.</p> Source code in <code>src/arv/gaussian/make_polynomial_coefficients.py</code> <pre><code>def fit_polynomal_approx_coefficients(*,\n                                      poly_order: int,\n                                      n_fit: int,\n                                      table_size: int) -&gt; npt.NDArray:\n    \"\"\"\n    Find the coefficients of the polynomial approximation of the inverse Gaussian CDF by a least squares polynomial fit.\n    Parameters\n    ----------\n    poly_order:\n        Order of polynomial.\n    n_fit:\n        The number of points to sample in dyadic (exponentially distributed) to fit polynomial.\n    table_size:\n        The number of entries in the resulting table.\n\n    Returns\n    -------\n    Coefficients:\n        The polynomial coefficients.\n    \"\"\"\n    n_poly = poly_order + 1  # Accounting for the constant term.\n    a = np.zeros((n_poly, table_size), dtype=float)\n    for m in range(1, table_size):\n        u2 = 0.5 ** m\n        u1 = u2 * 0.5 if m != (table_size - 1) else 0\n        x = np.linspace(u1, u2, n_fit)\n        x = 0.5 * (x[:-1] + x[1:])\n        y = norm.ppf(x)\n        a[:, m] = np.polyfit(x, y, deg=poly_order)[::-1]  # Finding the coefficients by weighted least squares.\n    return a\n</code></pre>"},{"location":"user_documentation/pyarv/gaussian/polynomial.html","title":"polynomial","text":""},{"location":"user_documentation/pyarv/gaussian/polynomial.html#pyarv.gaussian.polynomial.polynomial","title":"<code>polynomial(*, input, output, order=1)</code>","text":"<p>Polynomial approximation to the inverse CDF of the Gaussian ditribution.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Array</code> <p>Uniform random numbers in the range .</p> required <code>output</code> <code>Array</code> <p>Approximate Gaussian random variables.</p> required <code>order</code> <code>int</code> <p>The polynomial order to use:</p> <p>1 = linear. 3 = cubic.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>output</code> <code>None</code> <p>The approximate Gaussian random variables.</p> Source code in <code>src/pyarv/gaussian/polynomial.py</code> <pre><code>def polynomial(*,\n               input: Array,\n               output: Array,\n               order: int = 1\n               ) -&gt; None:\n    \"\"\"\n    Polynomial approximation to the inverse CDF of the Gaussian ditribution.\n\n    Parameters\n    ----------\n    input:\n        Uniform random numbers in the range \\( (0, 1) \\).\n    output:\n        Approximate Gaussian random variables.\n    order:\n        The polynomial order to use:\n\n        1 = linear.\n        3 = cubic.\n    Returns\n    -------\n    output:\n        The approximate Gaussian random variables.\n    \"\"\"\n    approximations = {1: linear,\n                      3: cubic}\n    approximations[order](input=input, output=output)\n</code></pre>"}]}